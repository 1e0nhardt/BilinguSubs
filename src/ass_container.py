import os

from utils import LOGGER, timestring_to_ms
from src.srt_container import Clip


SCRIPT_INFO = """
[Script Info]
; Script generated by 1e0nhardt's tool
; https://github.com/1e0nhardt/BilinguSubs
ScriptType: v4.00+
ScaledBorderAndShadow: Yes
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0
""".strip()

STYLES = """
[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: ZH,思源宋体,50,&H00FFFFFF,&HF0000000,&H00000000,&H32000000,0,0,0,0,100,100,0,0,1,2,1,2,5,5,10,1
Style: EN,Helvetica,34,&H00FFFFFF,&HF0000000,&H00000000,&H32000000,0,0,0,0,100,100,0,0,1,2,1,2,5,5,10,1
""".strip()

class AssContainer(object):

    def __init__(self) -> None:
        self.clips = []
        self.current_index = -1
        self.styles = []
        self.valid_style_names = []

    def is_empty(self) -> bool:
        return len(self.clips) == 0
    
    def get_current_clip(self) -> Clip:
        if len(self.clips) == 0:
            return
        return self.clips[self.current_index]

    def get_current_prev_clip(self) -> Clip:
        if self.current_index == 0:
            return None
        return self.clips[self.current_index - 1]

    def get_current_next_clip(self) -> Clip:
        if self.current_index + 2 > len(self.clips):
            return None
        return self.clips[self.current_index + 1]

    def udpate_current_clip(self, new_text):
        self.clips[self.current_index].update_text(new_text)
    
    def get_start_time_ms(self):
        return timestring_to_ms(self.start, ass=True)

    def get_end_time_ms(self):
        return timestring_to_ms(self.end, ass=True)
    
    def time_in_clip(self, ptime):
        return ptime > self.get_start_time_ms() and ptime < self.get_end_time_ms()
    
    def update_current_clip(self, play_time: float) -> bool:
        if self.get_current_clip() is None:
            return 

        if self.get_current_clip().time_in_clip(play_time):
            return False
        
        if self.clips[self.current_index + 1].time_in_clip(play_time):
            self.current_index += 1
        else:
            for i in range(len(self.clips)):
                if self.clips[i].get_end_time_ms() > play_time:
                    break
            self.current_index = i
        
        return True
    
    def load_srt(self, path):
        self.clips.clear()
        if not os.path.isfile(path):
            LOGGER.error(f"字幕加载失败，路径{path}不存在")
            return

        with open(path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        current_section = ''
        for lineno, line in enumerate(lines):
            if lineno == 0:
                # 文件开头有BOM头\ufeff，因此用==判断会出错
                assert "[Script Info]" in line
                current_section = 'script'
                continue

            if line.strip() == '[V4+ Styles]':
                current_section = 'style'
                continue
            elif line.strip() == '[Events]':
                current_section = 'events'
                continue

            if line.startswith('Format'):
                    continue

            if current_section == 'events':
                if line.startswith('Comment'):
                    continue
                elif line.startswith('Dialogue'):
                    params = line.split(': ')[1].split(',', maxsplit=9)
                    clip = Clip(self.valid_style_names)
                    clip.type = 'ass'
                    clip.set_id(lineno)
                    clip.start = params[1]
                    clip.end = params[2]
                    clip.style['Style'] = params[3]
                    clip.style['MarginL'] = params[5]
                    clip.style['MarginR'] = params[6]
                    clip.style['MarginV'] = params[7]
                    text = params[9]
                    if text.find('\\N') != -1:
                        clip.source_text, clip.target_text = text.split('\\N')
                    else:
                        clip.source_text = params[9]
                    self.clips.append(clip)
                else:
                    LOGGER.warning(f"ASS FORMAT INVALID at {lineno}: {line}")
            elif current_section == 'style':
                if line.startswith('Style'):
                    params = line.split(': ')[1].split(',')
                    self.valid_style_names.append(params[0])
                    self.styles.append({
                        'Name': params[0],
                        'Fontname': params[1],
                        'Fontsize': params[2],
                        'PrimaryColour': params[3],
                        'SecondaryColour': params[4],
                        'OutlineColour': params[5],
                        'BackColour': params[6],
                        'Bold': params[7],
                        'Italic': params[8],
                        'Underline': params[9],
                        'StrikeOut': params[10],
                        'ScaleX': params[11],
                        'ScaleY': params[12],
                        'Spacing': params[13],
                        'Angle': params[14],
                        'BorderStyle': params[15],
                        'Outline': params[16],
                        'Shadow': params[17],
                        'Alignment': params[18],
                        'MarginL': params[19],
                        'MarginR': params[20],
                        'MarginV': params[21],
                        'Encoding': params[22],
                    })

            else:
                continue

    def export_srt(self):
        srt_text = SCRIPT_INFO + '\n\n' + STYLES + '\n\n' + '[Events]\n' + 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n'
        
        for clip in self.clips:
            srt_text += f"Dialogue: "
            srt_text += f"0,{clip.start},{clip.end},{clip.style.get('Style', self.styles[0]['Name'])},"
            srt_text += f",{clip.style.get('MarginL', 0)},{clip.style.get('MarginR', 0)},{clip.style.get('MarginV', 0)},"
            srt_text += f",{clip.source_text}\\N{clip.target_text.strip()}\n"
        
        return srt_text
    
    def get_timeline(self, t):
        """1234.12 -> xx:xx:xx,xx (h:m:s,ms)"""
        seconds = int(t)
        ms = round(t - seconds, 3)
        ms = f'{ms:.2f}'[2:]
        minutes = seconds // 60
        seconds %= 60
        hours = minutes // 60
        minutes %= 60
        return f'{hours:02d}:{minutes:02d}:{seconds:02d}.{ms}'
    
    